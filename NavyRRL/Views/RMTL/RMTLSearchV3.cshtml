@using Models.Schema;
@using Newtonsoft.Json;
@using Models.DTO;
@{
	ViewBag.Title = "RMTL Search";
	var conceptSchemeMap = Factories.ConceptSchemeManager.GetConceptSchemeMap( true );
	var allConceptSchemes = conceptSchemeMap.AllConceptSchemes.Select( scheme => new SimpleFilter()
	{
		URI = scheme.SchemaUri,
		RowId = scheme.RowId,
		Id = scheme.Id,
		Name = scheme.Name,
		Items = scheme.Concepts.Select( concept => new SimpleFilterItem()
		{
			RowId = concept.RowId,
			Id = concept.Id,
			Label = string.Join( " - ", new List<string>() { concept.CodedNotation, concept.Name }.Where( m => !string.IsNullOrWhiteSpace( m ) ).ToList() ),
			Name = concept.Name,
			CodedNotation = concept.CodedNotation,
			WorkElementType = concept.WorkElementType
		} ).ToList()
	} ).ToList();

	allConceptSchemes.Add( new SimpleFilter()
	{
		URI = "UtilityFilters",
		Name = "Utility Filters",
		Items = new List<SimpleFilterItem>()
		{
			new SimpleFilterItem()
			{
				Label = "Limit results to Rating-level Tasks associated with more than one Pay Grade Level (A/J/M)",
				Name = "> PayGradeLevelTypeId > Concept.MultipleForRatingTask",
				Id = 0
			},
			new SimpleFilterItem()
			{
				Label = "Limit results to Rating-level Tasks associated with more than one Rank (Pay Grade)",
				Name = "> PayGradeTypeId > Concept.MultipleForRatingTask",
				Id = 0
			}
		}
	} );

	var preselectedRating = new Rating();
	if ( !string.IsNullOrWhiteSpace( Request.Params[ "RatingRowID" ] ) )
	{
		try
		{
			preselectedRating = Factories.RatingManager.GetByRowId( Guid.Parse( Request.Params[ "RatingRowID" ] ) );
		}
		catch { }
	}
}
@functions {
	public class SimpleFilter
	{
		public string URI { get; set; }
		public Guid RowId { get; set; }
		public int Id { get; set; }
		public string Name { get; set; }
		public List<SimpleFilterItem> Items { get; set; }
	}

	public class SimpleFilterItem
	{
		public Guid RowId { get; set; }
		public int Id { get; set; }
		public string Label { get; set; }
		//public Guid IsChildOf { get; set; }
		public string Name { get; set; }
		public string CodedNotation { get; set; }
		public string WorkElementType { get; set; }
	}
}

@Html.Partial( "~/Views/Shared/_AJAXTools.cshtml" )
@Html.Partial( "~/Views/Search/_SearchCoreV1.cshtml" )

<script type="text/javascript">
	var UI = {};
	var ConceptSchemes = @Html.Raw( JsonConvert.SerializeObject( allConceptSchemes ) );
	var RMTL = {
		Columns: [
			{ Label: "Rating Context UUID", Path: "> RowId", Part: "PART I", MinWidth: 200, IsMetaColumn: true },
			{ Label: "Rating", Path: "> HasRating > Rating > CodedNotation", Part: "PART I", MinWidth: 100 },
			{ Label: "Rank", Path: "> PayGradeType > Concept > CodedNotation", Part: "PART I", MinWidth: 100 },
			{ Label: "Level (A/J/M)", Path: "> PayGradeLevelType > Concept > CodedNotation", Part: "PART I", MinWidth: 100 },
			{ Label: "Billet Title/Job", Path: "> HasBilletTitle > BilletTitle > Name", Part: "PART I", MinWidth: 300 },
			{ Label: "Functional Area", Path: "> HasWorkRole > WorkRole > Name", Part: "PART I", MinWidth: 200 },
			{ Label: "Source", Path: "> HasRatingTask > RatingTask > HasReferenceResource > ReferenceResource > Name", Part: "PART I", MinWidth: 200 },
			{ Label: "Date of Source", Path: "> HasRatingTask > RatingTask > HasReferenceResource > ReferenceResource > PublicationDate", AsPlainText: true, Part: "PART I", MinWidth: 100 },
			{ Label: "Work Element Type", Path: "> HasRatingTask > RatingTask > ReferenceType > Concept > WorkElementType", Part: "PART I", MinWidth: 200 },
			{ Label: "Work Element (Task)", Path: "> HasRatingTask > RatingTask > Description", Part: "PART I", MinWidth: 500 },
			{ Label: "Task Applicability", Path: "> ApplicabilityType > Concept > Name", Part: "PART I", MinWidth: 150 },
			{ Label: "Formal Training Gap", Path: "> TrainingGapType > Concept > Name", Part: "PART II", MinWidth: 100 },
			{ Label: "Course Context UUID", Path: "> HasCourseContext > CourseContext > RowId", Part: "PART II", MinWidth: 200, IsMetaColumn: true },
			{ Label: "CIN", Path: "> HasCourseContext > CourseContext > HasCourse > Course > CodedNotation", AsPlainText: true, Part: "PART II", MinWidth: 100 },
			{ Label: "Course Name", Path: "> HasCourseContext > CourseContext > HasCourse > Course > Name", Part: "PART II", MinWidth: 300 },
			{ Label: "Course Type", Path: "> HasCourseContext > CourseContext > HasCourse > Course > CourseType > Concept > Name", Part: "PART II", MinWidth: 200 },
			{ Label: "Curriculum Control Authority (CCA)", Path: "> HasCourseContext > CourseContext > HasCourse > Course > CurriculumControlAuthority > Organization > Name", MinWidth: 200, Part: "PART II" },
			{ Label: "Life-Cycle Control Document", Path: "> HasCourseContext > CourseContext > HasCourse > Course > LifeCycleControlDocumentType > Concept > Name", Part: "PART II", MinWidth: 100 },
			{ Label: "TCCD/CTTL/PPP Statement", Path: "> HasCourseContext > CourseContext > HasTrainingTask > TrainingTask > Description", Part: "PART II", MinWidth: 500 },
			{ Label: "Current Assessment Approach", Path: "> HasCourseContext > CourseContext > AssessmentMethodType > Concept > Name", Part: "PART II", MinWidth: 300 },
			{ Label: "Training Solution Type", Path: "> HasClusterAnalysis > ClusterAnalysis > TrainingSolutionType > Concept > Name", Part: "PART III", MinWidth: 100 },
			{ Label: "Cluster Analysis UUID", Path: "> HasClusterAnalysis > ClusterAnalysis > RowId", Part: "PART III", MinWidth: 200, IsMetaColumn: true },
			{ Label: "Cluster Analysis Title", Path: "> HasClusterAnalysis > ClusterAnalysis > HasClusterAnalysisTitle > ClusterAnalysisTitle > Name", Part: "PART III", MinWidth: 300 },
			{ Label: "Recommended Modality", Path: "> HasClusterAnalysis > ClusterAnalysis > RecommendedModalityType > Concept > Name", Part: "PART III", MinWidth: 100 },
			{ Label: "Development Specification", Path: "> HasClusterAnalysis > ClusterAnalysis > DevelopmentSpecificationType > Concept > Name", Part: "PART III", MinWidth: 150 },
			{ Label: "Candidate Platform", Path: "> HasClusterAnalysis > ClusterAnalysis > CandidatePlatformType > Concept > CodedNotation", Part: "PART III", MinWidth: 200, Separator: "/" },
			{ Label: "CFM Placement", Path: "> HasClusterAnalysis > ClusterAnalysis > CFMPlacementType > Concept > Name", Part: "PART III", MinWidth: 150, Separator: "/" },
			{ Label: "Priority Placement", Path: "> HasClusterAnalysis > ClusterAnalysis > PriorityPlacement", Part: "PART III", MinWidth: 100 },
			{ Label: "Development Ratio", Path: "> HasClusterAnalysis > ClusterAnalysis > DevelopmentRatioType > Concept > Name", Part: "PART III", MinWidth: 100 },
			{ Label: "Estimated Instructional Time", Path: "> HasClusterAnalysis > ClusterAnalysis > EstimatedInstructionalTime", Part: "PART III", MinWidth: 100 },
			{ Label: "Development Time (duration in hours)", Path: "> HasClusterAnalysis > ClusterAnalysis > DevelopmentTime", Part: "PART III", Part: "PART III", MinWidth: 100 },
			{ Label: "Notes", Path: "> Notes", AsPlainText: true, Part: "PART III", MinWidth: 200 }
		]
	};
	var Statistics = {
		AllTasksTotal: 0,
		ReferenceResourceConcepts: @Html.Raw( JsonConvert.SerializeObject( conceptSchemeMap.ReferenceResourceCategory.Concepts.Select( m => SimpleItemHelper.GetSimpleItem( m ) ).ToList() ) ),
		TrainingGapConcepts: @Html.Raw( JsonConvert.SerializeObject( conceptSchemeMap.TrainingGapCategory.Concepts.Select( m => SimpleItemHelper.GetSimpleItem( m ) ).ToList() ) ),
		PayGradeLevelConcepts: @Html.Raw( JsonConvert.SerializeObject( conceptSchemeMap.PayGradeLevelCategory.Concepts.Select( m => SimpleItemHelper.GetSimpleItem( m ) ).ToList() ) ),
		PayGradeConcepts: @Html.Raw( JsonConvert.SerializeObject( conceptSchemeMap.PayGradeCategory.Concepts.Select( m => SimpleItemHelper.GetSimpleItem( m ) ).ToList() ) ),
		StatColumns: [
			{ getLabel: (table) => table.attr("data-typeheader") },
			{ Label: "Tasks" },
			{ Label: "Gaps" },
			{ Label: "Coverage %" },
			{ Label: "Gaps %" },
			{ Label: "% of Tasks in Results" },
			{ Label: "Coverage in Results" },
			{ Label: "% of All Tasks" },
			{ Label: "Coverage Across All Tasks" }
		]
	};
	var MainSearch = {};
	//

	$(document).ready(function () {
		setupUI();
		setupMainSearch();
		setupExport();
		preCacheResources();
		handlePreselectedRating();
	});
	//

	function handlePreselectedRating() {
		var Rating = @Html.Raw( JsonConvert.SerializeObject( preselectedRating, Formatting.None ) );
		if (Rating?.Id) {
			MainSearch.Filters.ByName["> RatingId > Rating"].addSelectedItem(Rating);
		}
	}
	//

	function preCacheResources() {
		ConceptSchemes.forEach(ConceptScheme => {
			MainSearch.addResourceToCache("@Url.Content("~/ConceptScheme/GetById/")" + ConceptScheme.Id, ConceptScheme);
			MainSearch.addResourceToCache("@Url.Content("~/ConceptScheme/GetByRowId/")" + ConceptScheme.RowId, ConceptScheme);
			ConceptScheme.Items.forEach(Concept => {
				MainSearch.addResourceToCache("@Url.Content("~/Concept/GetById/")" + Concept.Id, Concept);
				MainSearch.addResourceToCache("@Url.Content("~/Concept/GetByRowId/")" + Concept.RowId, Concept);
			});
		});
	}
	//

	function setupUI() {
		//Parts
		UI.MainHeader = $(".mainHeader");
		UI.Status = {
			StatusBox: $(".mainSearchStatusBox"),
			Spinner: $(".mainSearchSpinner"),
			FilterEchoBox: $(".mainSearchFilterEchoBox")
		};
		UI.ExportResultsProgressBarBox = $(".exportProgressBarBox");
		UI.ExportResultsProgressBar = $(".exportProgressBar");
		UI.MainFilters = {
			Box: $(".mainSearchFiltersBox")
		};
		UI.RMTL = {
			Box: $(".rmtlBox"),
			TableWrapper: $(".rmtlTableWrapper"),
			Table: $(".rtmlTable"),
			TableHeader: $(".rmtlTableHeader"),
			TableBody: $(".rmtlTableBody"),
			Footer: $(".rmtlFooter"),
			PagingBox: $(".rmtlPagingBox"),
			StyleBox: $(".rmtlStyleBox")
		};
		UI.Statistics = {
			Box: $(".statisticsBox"),
			BySourceTable: $(".ratingTasksBySourceTypeTable"),
			BySourceTableHeader: $(".ratingTasksBySourceTypeTableHeader"),
			BySourceTableBody: $(".ratingTasksBySourceTypeTableBody"),
			BySourceTableFooter: $(".ratingTasksBySourceTypeTableFooter"),
			ByLevelTable: $(".ratingTasksByPayGradeLevelTable"),
			ByLevelTableHeader: $(".ratingTasksByPayGradeLevelTableHeader"),
			ByLevelTableBody: $(".ratingTasksByPayGradeLevelTableBody"),
			ByLevelTableFooter: $(".ratingTasksByPayGradeLevelTableFooter"),
			ByPayGradeTable: $(".ratingTasksByPayGradeTable"),
			ByPayGradeTableHeader: $(".ratingTasksByPayGradeTableHeader"),
			ByPayGradeTableBody: $(".ratingTasksByPayGradeTableBody"),
			ByPayGradeTableFooter: $(".ratingTasksByPayGradeTableFooter")
		};

		//Buttons
		UI.ExportResultsButton = $("[data-action='ExportMainSearchResults']");
		UI.CancelExportMainSearchResultsButton = $("[data-action='CancelExportMainSearchResults']");

		//Initialization
		UI.MainTabs = setupTabs($(".mainTabButtons"), $(".mainTab"));
		UI.MainTabs.TabsByName["RMTL Spreadsheet"].resetScroll = function () {
			UI.RMTL.TableWrapper[0].scrollTo(0, 0);
		}

		RMTL.Columns.forEach(Column => {
			Column.THead = $("<th data-column=\"" + Column.Label + "\" data-part=\"" + Column.Part + "\" style=\"min-width: " + (Column.MinWidth) + "px\">" + Column.Label + "</th>").appendTo(UI.RMTL.TableHeader);
		});

		UI.ExportResultsProgressBarBox.hide();
		UI.CancelExportMainSearchResultsButton.hide();

		buildStatTable(UI.Statistics.BySourceTable, UI.Statistics.BySourceTableHeader);
		buildStatTable(UI.Statistics.ByLevelTable, UI.Statistics.ByLevelTableHeader);
		buildStatTable(UI.Statistics.ByPayGradeTable, UI.Statistics.ByPayGradeTableHeader);

		//Helper function
		function buildStatTable(Table, TableHeader) {
			var tableHeaderTR = $("<tr></tr>").appendTo(TableHeader);
			Statistics.StatColumns.forEach(Column => {
				var label = Column.Label || Column.getLabel(Table);
				$("<th data-column=\"" + label + "\">" + label + "</th>").appendTo(tableHeaderTR);
			});
		}
	}
	//

	function setupTabs(jqTabButtonsBox, jqTabs) {
		//Container
		var TabSet = {
			Tabs: [],
			TabsByName: {},
			CurrentTab: null
		};

		//Show Tab
		TabSet.showTab = function (Tab) {
			TabSet.CurrentTab = Tab;

			TabSet.Tabs.forEach(OtherTab => {
				OtherTab.Box.removeClass("selected");
				OtherTab.Button.removeClass("selected greenButton");
			});

			Tab.Box.addClass("selected");
			Tab.Button.addClass("selected greenButton");

			if (Tab.ResetScroll) {
				Tab.ResetScroll = false;
				Tab.resetScroll();
			}
		};

		//Setup individual tabs
		jqTabs.each(function () {
			var box = $(this);
			var Tab = {
				Box: box,
				Name: box.attr("data-tab"),
				Button: $("<button>" + box.attr("data-tab") + "</button>").appendTo(jqTabButtonsBox),
				ResetScroll: false
			};

			Tab.Button.on("click", function () {
				TabSet.showTab(Tab);
			});

			Tab.resetScroll = function () { }; //Override this

			TabSet.Tabs.push(Tab);
			TabSet.TabsByName[Tab.Name] = Tab;
		});

		//Hidden elements can't be scrolled, so defer it
		TabSet.resetScrollForOtherTabs = function () {
			TabSet.Tabs.filter(Tab => Tab != TabSet.CurrentTab).forEach(Tab => Tab.ResetScroll = true);
		}

		//Show the first tab
		TabSet.Tabs[0]?.Button.trigger("click");

		//Tracking
		return TabSet;
	}
	//

	function setupMainSearch() {
		//Create the Search and Setup the Filters
		MainSearch = createSearch("RMTL", "@Url.Content("~/RMTL/DoSearch")", UI.Status.StatusBox, UI.Status.Spinner, UI.RMTL.TableBody, UI.RMTL.PagingBox, 250, 1000); //Page size here must not exceed max page size server-side!
		MainSearch.Filters = setupFilters(UI.MainFilters.Box.find(".filter"));
		MainSearch.Enabled = true;

		//Inject Enable/Disable functionality to avoid collisions between search and export
		MainSearch.enable = function () {
			MainSearch.Enabled = true;
			MainSearch.Filters.List.forEach(Filter => {
				Filter.enable();
			});
		};

		MainSearch.disable = function () {
			MainSearch.Enabled = false;
			MainSearch.Filters.List.forEach(Filter => {
				Filter.disable();
			});
		};

		//Override the appropriate functions
		MainSearch.getFilters = function () {
			return MainSearch.Filters.List.filter(Filter => !Filter.IsMetaFilter).map(Filter => Filter.read()).flatMap(filterData => filterData).filter(value => value);
		};

		MainSearch.getSortOrder = function () {
			return MainSearch.Filters.ByName.SortOrder.read();
		};

		MainSearch.beforeRenderAll = function () {
			UI.RMTL.TableWrapper[0].scrollTo(0, 0);
		};

		MainSearch.afterRenderAll = function () {
			getAndRenderStatistics();
		};

		MainSearch.renderResult = function (Result, container, index) {
			var row = $("<tr></tr>").appendTo(container);
			RMTL.Columns.forEach(Column => {
				var cell = $("<td><div class=\"spinner\"></div></td>").appendTo(row);
				setTimeout(function () {
					//Column.render(Result, cell);
					renderPathToData(Column, Result, cell);
				}, index);
			});
		};
	}
	//

	function setupFilters(jqFilters) {
		//Container
		var Filters = {
			List: [],
			ByName: {}
		}

		//For each Filter...
		jqFilters.each(function () {
			var box = $(this);
			var Filter = {
				Box: box,
				Name: box.attr("data-filter"),
				Type: box.attr("data-filtertype"),
				SearchType: box.attr("data-searchtype"),
				Source: ConceptSchemes.find(scheme => scheme.URI == box.attr("data-sourceuri"))
			};

			Filter.Label = box.attr("data-label") || Filter.Source?.Name || Filter.Name;
			Filter.LabelBox = $("<div class=\"filterLabel\">" + Filter.Label + "</div>").appendTo(Filter.Box);
			Filter.ContentBox = $("<div class=\"filterContent\"></div>").appendTo(Filter.Box);

			window["setupFilter_" + Filter.Type]?.(Filter);

			Filters.List.push(Filter);
			Filters.ByName[Filter.Name] = Filter;
		});

		//Tracking
		return Filters;
	}
	//

	function renderPathToData(Column, Result, cell, onFinish) {
		//Get the path parts
		var path = Column.Path.replace(/>/g, "").split(" ").map(m => m.trim()).filter(m => m);
		//Do the referencing
		referenceViaPath(Column, path, Result, "RatingContext", cell, false, onFinish);
	}
	function referenceViaPath(Column, path, CurrentData, currentType, container, replaceContainer, onFinish, overrideRenderType, overrideRenderID) {
		//Get the property and type data
		var nextProperty = path.shift();
		var nextType = path.shift();
		//If the path continues, crawl it
		if (nextType) {
			var value = CurrentData[nextProperty];
			if (value) {
				//Handle array values
				if (Array.isArray(value)) {
					//Handle empty arrays
					if (value.length == 0) {
						writeValue(container, "N/A", replaceContainer, onFinish);
					}
					else {
						//Clear the container and handle rendering separators
						container.html("");
						var addSeparator = false;
						var finished = value.map(m => { return false });
						//For each value...
						value.forEach((item, index) => {
							//Inject a separator and a placeholder
							addSeparator ? container.append(Column.Separator || " | ") : (addSeparator = true);
							var placeholder = $("<div class=\"spinner\"></div>").appendTo(container);
							//Get the value and continue the process
							if (item == "@Guid.Empty") {
								writeValue(placeholder, "N/A", true, onFinish);
							}
							else {
								MainSearch.getRelatedResourceOrLookup(item, "@Url.Content("~/")" + nextType + "/GetByRowId/" + item, NextData => {
									referenceViaPath(Column, [...path], NextData, nextType, placeholder, true, function () {
										finished[index] = true;
										if (finished.every(m => m == true)) {
											onFinish?.();
										}
									}, overrideRenderType, overrideRenderID);
								}, Error => {
									writeValue(placeholder, "Error loading data for UUID: " + item, replaceContainer, onFinish);
								});
							}
						});
					}
				}
				//Handle single values
				else {
					if (value == "@Guid.Empty") {
						writeValue(container, "N/A", replaceContainer, onFinish);
					}
					else {
						MainSearch.getRelatedResourceOrLookup(value, "@Url.Content("~/")" + nextType + "/GetByRowId/" + value, NextData => {
							referenceViaPath(Column, path, NextData, nextType, container, false, onFinish, overrideRenderType, overrideRenderID);
						}, Error => {
							writeValue(container, "Error loading data for UUID: " + item, replaceContainer, onFinish);
						});
					}
				}
			}
			else {
				writeValue(container, "N/A", replaceContainer, onFinish);
			}
		}
		//Otherwise, render the value
		else {
			if (CurrentData[nextProperty]) {
				var content = Column.AsPlainText ? CurrentData[nextProperty] : $("<a href=\"@Url.Content("~/")" + (overrideRenderType || currentType) + "/Detail/" + (overrideRenderID || CurrentData.Id) + "\" target=\"_blank\">" + CurrentData[nextProperty] + "</a>");
				writeValue(container, content, replaceContainer, onFinish);
			}
			else {
				writeValue(container, "N/A", replaceContainer, onFinish);
			}
		}
	}

	//Helper function
	function writeValue(container, value, replaceContainer, onFinish) {
		replaceContainer ? container.replaceWith(value) : container.html(value);
		onFinish?.();
	}
	//

	//Export handling
	function setupExport() {
		UI.ExportResultsButton.on("click", function () {
			if (MainSearch.Busy) {
				alert("A search is still in progress. Please wait until the total results are available for the current query before exporting the data.");
				return;
			}
			if (!MainSearch.TotalPages > 0) {
				alert("Error: the current query returns 0 results.");
				return;
			}

			exportResults();
		});

		UI.CancelExportMainSearchResultsButton.on("click", function () {
			finishExport();
		});
	}
	//

	function exportResults() {
		UI.ExportEnabled = true;
		UI.CancelExportMainSearchResultsButton.show();
		UI.ExportResultsButton.hide();
		//UI.ExportResultsButton.prop("disabled", true).html("Processing");
		MainSearch.disable();
		UI.ExportResultsProgressBarBox.show();
		UI.ExportResultsProgressBar.html("Processing...");
		UI.Status.Spinner.show();
		UI.HasWrittenExport = false;
		setTimeout(function () {
			var allResults = [];
			exportResultsPage(1, allResults, 0);
		}, 1500);
	}
	//

	function exportResultsPage(pageNumber, allResults, totalHandled) {
		if (!UI.ExportEnabled) {
			return;
		}

		//Set the page number and prepare the search
		MainSearch.PageNumber = pageNumber;
		MainSearch.prepareToSearch(false, false);

		//Do the search
		MainSearch.doPOSTRequest(MainSearch.SearchURL, MainSearch.Query, response => {
			if (!UI.ExportEnabled) {
				return;
			}
			//If valid...
			if (response.Valid) {
				//Set the related resources array so that the rendering code will find them
				MainSearch.RelatedResources = response.Data.RelatedResources || []; //Should this append data instead?
				//Create an array of flags, one for each Result
				var resultsFlags = response.Data.Results.map(m => { return false; });
				var VisibleColumns = RMTL.Columns.filter(Column => Column.Visible);
				//For each result...
				response.Data.Results.forEach((Result, resultIndex) => {
					//Create a work row and an output row
					//Populate the work row with all of its cells
					var workRow = VisibleColumns.map(Column => {
						return {
							cell: $("<div></div>"),
							finished: false
						}
					});
					//Append the output row immediately to ensure the rows remain in the correct order
					var outputRow = [];
					allResults.push(outputRow);
					//Now populate the cells
					VisibleColumns.forEach((Column, index) => {
						var item = workRow[index];
						//Render the data for the fake cell. Include callback that sets the item's value to "finished" when it's done
						//Column.render(Result, item.cell, function () {
						renderPathToData(Column, Result, item.cell, function () {
							if (!UI.ExportEnabled) {
								return;
							}
							item.finished = true;
							//If all of the items for the current workRow are finished...
							if (workRow.every(m => m.finished)) {
								//Get the .text() for each cell and append it to the outputRow
								workRow.forEach(workRowItem => {
									outputRow.push(workRowItem.cell.text());
								});
								//Flag this result as being finished
								resultsFlags[resultIndex] = true;
								totalHandled++;
								UI.ExportResultsProgressBar.css("width", (100 * ( totalHandled / (response.Data.TotalResults || 1) )) + "%").html(totalHandled + " of " + response.Data.TotalResults);
								//If every Result for the current page is finished...
								if (resultsFlags.every(m => m == true)) {
									//If there are more results to get, get them
									if (pageNumber < MainSearch.TotalPages) {
										exportResultsPage(pageNumber + 1, allResults, totalHandled);
									}
									//Otherwise finish and write the CSV data
									else {
										UI.ExportResultsProgressBar.css("width", "100%").html("Generating CSV File...");
										console.log("Writing CSV File");
										writeCSV(allResults, finishExport);
									}
								}
							}
						});
					});
				});
			}
			else {
				console.log("Export error: " + response);
				MainSearch.setStatus("Error: " + response.Status.join(", "));
				finishExport();
			}
		}, error => {
			console.log("Error", error);
			MainSearch.setStatus("Error: " + (error?.status || "Unknown Error"));
			finishExport();
		});
	}
	//

	function writeCSV(allResults, afterWrite) {
		if (UI.HasWrittenExport) {
			console.log("Received call to write an export that was already written!");
			return;
		}
		UI.HasWrittenExport = true;

		if (!UI.ExportEnabled) {
			return;
		}

		var currentPart = "";
		var csv = [];
		var topRow = [];
		var VisibleColumns = RMTL.Columns.filter(Column => Column.Visible);
		VisibleColumns.forEach(Column => {
			topRow.push(currentPart == Column.Part ? "" : Column.Part);
			currentPart = Column.Part;
		});
		csv.push(topRow.join(","));
		csv.push(VisibleColumns.map(Column => Column.Label).join(","));

		allResults.forEach(rowData => {
			csv.push(rowData.map(cell => {
				return cell.match(/["\r\n,]/) ? '"' + cell.replace(/"/g, '""') + '"' : cell;
			}).join(","));
		});
		var csvText = csv.join("\n");
		//console.log("CSV", csvText);

		var tempLink = $("<a></a>").appendTo(document.body);
		tempLink.attr("download", "RMTL Export.csv");
		tempLink.attr("href", URL.createObjectURL(new Blob([csvText], { type: "text/csv" })));
		tempLink[0].click();

		setTimeout(function () {
			tempLink.remove();
			afterWrite?.();
		}, 500);
	}
	//

	function finishExport() {
		UI.ExportEnabled = false;
		UI.CancelExportMainSearchResultsButton.hide();
		UI.ExportResultsButton.show();
		UI.ExportResultsProgressBar.css("width", "0");
		//UI.ExportResultsButton.prop("disabled", false).html("Export Results");
		MainSearch.enable();
		UI.ExportResultsProgressBarBox.hide();
		UI.ExportResultsProgressBar.html("");
		UI.Status.Spinner.hide();
	}
	//
</script>
<script type="text/javascript">
	//Statistics functions
	function getAndRenderStatistics() {
		MainSearch.doPOSTRequest(MainSearch.SearchURL, { ...MainSearch.Query, Filters: [], Skip: 0, Take: 0, SortOrder: [{ Column: "sortOrder:Unsorted" }] }, success => {
			Statistics.AllTasksTotal = success.Data.ExtraData.RatingTaskCount;
			getAndRenderStatisticsTable(Statistics.ReferenceResourceConcepts, Statistics.StatColumns, UI.Statistics.BySourceTableBody, UI.Statistics.BySourceTableFooter, "> RatingTaskId > RatingTask > ReferenceResourceTypeId > Concept", "Total from All Sources", (a, b) => { return a.ResultsTotal > b.ResultsTotal ? -1 : 1 });
			getAndRenderStatisticsTable([
				...Statistics.PayGradeLevelConcepts,
				{ Name: "Tasks Associated with Multiple Levels", Id: 0, OverrideFilterName: "> PayGradeLevelTypeId > Concept.MultipleForRatingTask" },
			], Statistics.StatColumns, UI.Statistics.ByLevelTableBody, UI.Statistics.ByLevelTableFooter, "> PayGradeLevelTypeId > Concept.ExclusiveToRatingTask", "Total from All Levels");
			getAndRenderStatisticsTable([
				...Statistics.PayGradeConcepts.map(m => { m.Label = m.CodedNotation + " - " + m.Name; return m; }),
				{ Name: "Tasks Associated with Multiple Pay Grades", Id: 0, OverrideFilterName: "> PayGradeTypeId > Concept.MultipleForRatingTask" },
			], Statistics.StatColumns, UI.Statistics.ByPayGradeTableBody, UI.Statistics.ByPayGradeTableFooter, "> PayGradeTypeId > Concept.ExclusiveToRatingTask", "Total from All Pay Grades");
		}, error => {
			console.log("Error getting Grand Total", error);
		});
	}
	//

	function getAndRenderStatisticsTable(Concepts, Columns, TableBody, TableFooter, nameFilterPath, totalFromAllText, sortFunction) {
		TableBody.html("<tr><td colspan=\"" + Columns.length + "\"><div class=\"spinner\"></div></td></tr>");
		TableFooter.html("");
		var CalculatedStats = Concepts.map(Concept => { return { Concept: Concept, ResultsTotal: 0, GapTotal: 0, Error: "", Finished: false } });
		CalculatedStats.forEach(Stat => {
			var alteredQuery = {
				...MainSearch.Query,
				Filters: [...MainSearch.Query.Filters, { Name: Stat.Concept.OverrideFilterName || nameFilterPath, ItemIds: [Stat.Concept.Id] }],
				Skip: 0,
				Take: 0,
				SortOrder: [{ Column: "sortOrder:Unsorted" }]
			};
			MainSearch.doPOSTRequest(MainSearch.SearchURL, alteredQuery, resultsSuccess => {
				Stat.ResultsTotal = resultsSuccess.Data.ExtraData.RatingTaskCount;
				if (Stat.ResultsTotal > 0) {
					alteredQuery.Filters.push({ Name: "> FormalTrainingGapId > Concept", ItemIds: Statistics.TrainingGapConcepts.filter(m => m.Name.toLowerCase() != "no").map(m => m.Id) });
					MainSearch.doPOSTRequest(MainSearch.SearchURL, alteredQuery, gapSuccess => {
						Stat.GapTotal = gapSuccess.Data.ExtraData.RatingTaskCount;
						handleFinished(Stat);
					}, error => {
						Stat.GapTotal = -99;
						Stat.Error = "Error loading gap data";
						handleFinished(Stat);
					});
				}
				else {
					handleFinished(Stat);
				}
			}, error => {
				Stat.ResultsTotal = -99;
				Stat.Error = "Error loading task data";
				handleFinished(Stat);
			});
		});

		function handleFinished(Stat) {
			Stat.Finished = true;
			if (CalculatedStats.every(OtherStat => OtherStat.Finished)) {
				sortFunction && (CalculatedStats = CalculatedStats.sort(sortFunction));
				TableBody.html("");
				var resultsTotal = CalculatedStats.reduce((total, Stat) => { return total + Stat.ResultsTotal; }, 0);
				var resultsAllTasksPercent = getPercent(resultsTotal, Statistics.AllTasksTotal);
				var gapTotal = CalculatedStats.reduce((total, Stat) => { return total + Stat.GapTotal }, 0);
				var gapPercent = getPercent(gapTotal, resultsTotal, false);
				var coveragePercent = resultsTotal <= 0 ? 0 : Math.round(100 * (100 - gapPercent)) / 100;
				CalculatedStats.forEach(Stat => {
					var statGapPercent = getPercent(Stat.GapTotal, Stat.ResultsTotal);
					var statCoveragePercent = Math.round(100 * (100 - statGapPercent)) / 100; //Prevents weird javascript floating point errors like 100 - 19.54 resulting in 80.46000000000001
					var statResultsTaskPercent = getPercent(Stat.ResultsTotal, resultsTotal);
					var statAllTasksTaskPercent = getPercent(Stat.ResultsTotal, Statistics.AllTasksTotal);
					TableBody.append("<tr>" + [
						Stat.Concept.Id == 0 ? Stat.Concept.Name : "<a href=\"@Url.Content("~/Concept/Detail/")" + Stat.Concept.Id + "\" target=\"_blank\">" + (Stat.Concept.Label || Stat.Concept.Name) + "</a>",
						Stat.ResultsTotal == -99 ? Stat.Error : Stat.ResultsTotal,
						Stat.GapTotal == -99 ? Stat.Error : Stat.GapTotal,
						statCoveragePercent + "%",
						statGapPercent + "%",
						statResultsTaskPercent + "%",
						renderStatBarWrapper(statResultsTaskPercent, statCoveragePercent),
						statAllTasksTaskPercent + "%",
						renderStatBarWrapper(statAllTasksTaskPercent, statCoveragePercent)
					].map((m, i) => "<td data-column=\"" + Columns[i].Label + "\">" + m + "</td>").join("") + "</tr>");
				});
				TableFooter.html("<tr>" +
					[totalFromAllText, resultsTotal, gapTotal, coveragePercent + "%", gapPercent + "%", "100%", renderStatBarWrapper(100, coveragePercent), resultsAllTasksPercent + "%", renderStatBarWrapper(resultsAllTasksPercent, coveragePercent)]
					.map((m, i) => "<th data-column=\"" + Columns[i].Label + "\">" + m + "</th>").join("") +
				"</tr>");
			}
		}
	}
	//

	function getPercent(x, y, includePercentSign) {
		return (y == 0 ? 0 : Math.round(10000 * x / y) / 100) + (includePercentSign ? "%" : 0);
	}
	//

	function renderStatBarWrapper(mainBarPercent, subBarPercent) {
		return "<div class=\"statBarWrapper\"><div class=\"statBarAll\" style=\"width:" + mainBarPercent + "%\"><div class=\"statBarCoverage\" style=\"width:" + subBarPercent + "%\"></div></div></div>";
	}
	//
</script>
<script type="text/javascript">
	//Filter Setup Functions
	//Utility Function
	function delayThenTriggerSearchIfAvailable(resetPaging) {
		if (MainSearch.Enabled) {
			UI.MainTabs.resetScrollForOtherTabs();
			MainSearch.delayThenSearch(resetPaging, true);
		}
	}

	//Setup Text Filter
	function setupFilter_Text(Filter) {
		Filter.Input = $("<input type=\"text\" placeholder=\"Enter keyword(s)...\" />").appendTo(Filter.ContentBox);

		Filter.Input.on("keyup", function () {
			delayThenTriggerSearchIfAvailable(true);
		});

		Filter.read = function () {
			var value = Filter.Input.val().trim();
			return value ? { Name: Filter.Name, Text: value } : null;
		}

		Filter.enable = function () {
			Filter.Input.prop("disabled", false);
		}

		Filter.disable = function () {
			Filter.Input.prop("disabled", true);
		}
	}
	//

	//Setup Suggestion Filter
	function setupFilter_Suggestion(Filter) {
		setupFilter_Suggestion_Core(Filter);
		Filter.Timeout = 0;
		Filter.SuggestionFilterExtras = [];
		Filter.HasDataHelper = Filter.Box.attr("data-hasdatahelper");
		Filter.TakeSuggestions = parseInt(Filter.Box.attr("data-takesuggestions") || "50");

		if (Filter.HasDataHelper) {
			Filter.SuggestionFilterExtras.push({ Name: Filter.HasDataHelper });
		}

		Filter.Input.on("focus keyup", function () {
			clearTimeout(Filter.Timeout);
			Filter.Timeout = setTimeout(function () {
				var FilterRequest = MainSearch.doPOSTRequest("@Url.Content("~/")" + Filter.SearchType + "/DoSearch", {
					Filters: [
						{ Name: "search:Keyword", Text: Filter.Input.val().trim() },
						{ Name: "search:Exclude", ItemIds: Filter.SelectedItems.map(SelectedItem => SelectedItem.Data.Id) },
						...Filter.SuggestionFilterExtras
					],
					Take: Filter.TakeSuggestions
				}, (success) => {
					Filter.Suggestions = success.Data.Results;
					Filter.renderSuggestions();
				});
				FilterRequest.Protected = true; //Ensure filter requests don't get canceled by changing search queries
			}, 500);
		});

		Filter.read = function () {
			var ids = Filter.SelectedItems.map(SelectedItem => SelectedItem.Data.Id);
			return ids.length == 0 ? null : { Name: Filter.Name, ItemIds: ids };
		}
	}
	//

	//Setup Local Suggestion Filter
	function setupFilter_SuggestionLocalConcept(Filter) {
		setupFilter_Suggestion_Core(Filter);
		Filter.Options = [...Filter.Source.Items];

		Filter.Input.on("focus keyup", function () {
			setTimeout(function () {
				var text = Filter.Input.val().trim().toLowerCase();
				Filter.Suggestions = Filter.Options.filter(Option => !Filter.SelectedItems.map(SelectedItem => SelectedItem.Data).includes(Option) && Option.Label.toLowerCase().includes(text));
				Filter.renderSuggestions();
			}, 0);
		});

		Filter.read = function () {
			var ids = Filter.SelectedItems.map(SelectedItem => SelectedItem.Data.Id);
			return ids.length == 0 ? null : { Name: Filter.Name, ItemIds: ids };
		}
	}
	//

	//Setup Sort Order Filter
	function setupFilter_SortOrder(Filter) {
		setupFilter_Suggestion_Core(Filter);
		Filter.Options = RMTL.Columns.map(Column => { return { Label: Column.Label, Column: Column.Path, Ascending: true }; })
			.concat(RMTL.Columns.map(Column => { return { Label: Column.Label + " (Reverse)", Column: Column.Path, Ascending: false }; }));

		Filter.Input.on("focus keyup", function () {
			setTimeout(function () {
				var text = Filter.Input.val().trim().toLowerCase();
				Filter.Suggestions = Filter.Options.filter(Option => !Filter.SelectedItems.map(SelectedItem => SelectedItem.Data).includes(Option) && Option.Label.toLowerCase().includes(text));
				Filter.renderSuggestions();
			}, 0);
		});

		Filter.IsMetaFilter = true;

		Filter.read = function () {
			return [{ Column: "sortOrder:RMTLSearchSortHandler" }].concat(Filter.SelectedItems.map(SelectedItem => SelectedItem.Data));
		}
	}
	//

	//Core Suggestion Filter
	function setupFilter_Suggestion_Core(Filter) {
		Filter.Suggestions = [];
		Filter.SelectedItems = [];

		Filter.Input = $("<input type=\"text\" placeholder=\"Find Item(s)...\" />").appendTo(Filter.ContentBox);
		Filter.SuggestionsBox = $("<div class=\"suggestionBox\"></div>").appendTo(Filter.ContentBox);
		Filter.SelectedItemsBox = $("<div class=\"selectedItemsBox\"></div>").appendTo(Filter.ContentBox);

		Filter.addSelectedItem = function (Data) {
			var SelectedItem = {
				Data: Data
			};

			Filter.SelectedItems.push(SelectedItem);
			Filter.renderSelectedItems();
			Filter.onSelectedItemsChange?.();
			delayThenTriggerSearchIfAvailable(true);
		}

		Filter.removeSelectedItem = function (SelectedItem) {
			Filter.SelectedItems = Filter.SelectedItems.filter(OtherSelectedItem => OtherSelectedItem != SelectedItem);
			Filter.renderSelectedItems();
			Filter.onSelectedItemsChange?.();
			delayThenTriggerSearchIfAvailable(true);
		}

		Filter.renderSelectedItems = function () {
			Filter.SelectedItemsBox.html("");
			Filter.SelectedItems.forEach(SelectedItem => {
				SelectedItem.Box = $("<div class=\"selectedItem\"></div>").appendTo(Filter.SelectedItemsBox);
				SelectedItem.Box.append("<span>" + Filter.getLabel(SelectedItem.Data) + "</span>");
				SelectedItem.RemoveButton = $("<button class=\"redButton\" title=\"Remove\">X</button>").appendTo(SelectedItem.Box);
				SelectedItem.RemoveButton.on("click", function () {
					Filter.removeSelectedItem(SelectedItem);
				});
			});
		}

		Filter.renderSuggestions = function () {
			Filter.SuggestionsBox.html("");
			var cancelButton = $("<button class=\"suggestion cancel\">Cancel</button>").appendTo(Filter.SuggestionsBox);
			cancelButton.on("click", function () {
				Filter.clearSuggestions();
			});
			Filter.Suggestions.forEach(Suggestion => {
				var button = $("<button class=\"suggestion\">" + Filter.getLabel(Suggestion) + "</div>").appendTo(Filter.SuggestionsBox);
				button.on("click", function () {
					Filter.addSelectedItem(Suggestion);
					Filter.clearSuggestions();
				});
			});
			Filter.Suggestions.length == 0 ? Filter.SuggestionsBox.hide() : Filter.SuggestionsBox.show();
		}

		Filter.clearSuggestions = function () {
			Filter.Input.val("");
			Filter.Suggestions = [];
			Filter.renderSuggestions();
		}

		Filter.getLabel = function (Data) {
			return Data.Label || [Data.CodedNotation, Data.Name || Data.Description || Data.Id || "Unknown Item"].filter(m => m).join(" - ");
		}

		Filter.Input.on("focus", function () {
			Filter.SuggestionsBox.show();
		});

		Filter.Input.on("blur", function () {
			setTimeout(function () {
				if (!Filter.SuggestionsBox.is(":hover") && Filter.SuggestionsBox.find("button:focus").length == 0) {
					Filter.SuggestionsBox.hide();
				}
			}, 10);
		});

		Filter.onSelectedItemsChange = function () {
			delayThenTriggerSearchIfAvailable(true);
		}

		Filter.enable = function () {
			Filter.Input.prop("disabled", false);
			Filter.SelectedItems.forEach(SelectedItem => {
				SelectedItem.RemoveButton.prop("disabled", false);
			});
		}

		Filter.disable = function () {
			Filter.clearSuggestions();
			Filter.Input.prop("disabled", true);
			Filter.SelectedItems.forEach(SelectedItem => {
				SelectedItem.RemoveButton.prop("disabled", true);
			});
		}

		Filter.SuggestionsBox.hide();
	}
	//

	//Checkbox List Filter
	function setupFilter_CheckBoxList(Filter) {
		setupFilter_CheckBoxList_Core(Filter, Filter.Source.Items, "Toggle All", function () {
			delayThenTriggerSearchIfAvailable(true);
		});

		Filter.read = function () {
			var ids = Filter.CheckBoxes.filter(CheckBox => CheckBox.Input.prop("checked")).map(CheckBox => CheckBox.Data.Id);
			return ids.length == 0 ? null : { Name: Filter.Name, ItemIds: ids };
		}
	}
	//

	//Show/Hide Columns Filter
	function setupFilter_ShowHideColumns(Filter) {
		setupFilter_CheckBoxList_Core(Filter, RMTL.Columns, "Show/Hide All", function () {
			Filter.refreshStyles();
		});

		Filter.refreshStyles = function () {
			UI.RMTL.StyleBox.html("");
			Filter.CheckBoxes.forEach((CheckBox, index) => {
				RMTL.Columns[index].Visible = CheckBox.Input.prop("checked");
				if (CheckBox.Input.prop("checked") == false) {
					UI.RMTL.StyleBox.append(".rmtlBox .rmtlTableWrapper .rmtlTable .rmtlTableHeader th:nth-child(" + (index + 1) + ") { display: none; }");
					UI.RMTL.StyleBox.append(".rmtlBox .rmtlTableWrapper .rmtlTable .rmtlTableBody td:nth-child(" + (index + 1) + ") { display: none; }");
				}
			});
		}

		Filter.IsMetaFilter = true;

		Filter.read = function () {
			return null;
		}

		//Initialize
		Filter.CheckBoxes.forEach((CheckBox, index) => {
			CheckBox.Input.prop("checked", !RMTL.Columns[index].IsMetaColumn);
		});
		RMTL.Columns.filter(Column => !Column.IsMetaColumn).forEach(Column => {
			Column.Visible = true;
		});
		Filter.refreshStyles();
	}
	//

	//Checkbox List Individual Items Filter
	function setupFilter_CheckBoxListIndividualItems(Filter) {
		setupFilter_CheckBoxList_Core(Filter, Filter.Source.Items, "Toggle All", function () {
			delayThenTriggerSearchIfAvailable(true);
		});

		Filter.read = function () {
			return Filter.CheckBoxes.filter(CheckBox => CheckBox.Input.prop("checked")).map(CheckBox => {
				return { Name: CheckBox.Data.Name, ItemIds: [CheckBox.Data.Id] }; //Must have an ID (an ID of 0 is fine) or the search process will ignore the filter
			});
		}
	}
	//

	//Core Checkbox Filter
	function setupFilter_CheckBoxList_Core(Filter, ItemList, toggleAllButtonLabel, onUpdate) {
		Filter.CheckBoxes = [];

		ItemList.forEach(Item => {
			var CheckBox = {
				Box: $("<label><input type=\"checkbox\"><span>" + Item.Label + "</span></label>").appendTo(Filter.ContentBox),
				Data: Item
			};

			CheckBox.Input = CheckBox.Box.find("input");
			CheckBox.Input.on("change", function () {
				onUpdate();
			});

			Filter.CheckBoxes.push(CheckBox);
		});

		Filter.ToggleButton = $("<button>" + toggleAllButtonLabel + "</button>").appendTo(Filter.LabelBox);
		Filter.ToggleButton.on("click", function () {
			var checked = Filter.CheckBoxes.every(CheckBox => CheckBox.Input.prop("checked"));
			Filter.CheckBoxes.forEach(CheckBox => CheckBox.Input.prop("checked", !checked));
			onUpdate();
		});

		Filter.enable = function () {
			Filter.ToggleButton.prop("disabled", false);
			Filter.CheckBoxes.forEach(CheckBox => CheckBox.Input.prop("disabled", false));
		}

		Filter.disable = function () {
			Filter.ToggleButton.prop("disabled", true);
			Filter.CheckBoxes.forEach(CheckBox => CheckBox.Input.prop("disabled", true));
		}
	}
	//
</script>
<style type="text/css">
	body { padding: 0 0 0 0; }
	.navbar { position: static; margin: 0 0 0 0; }
	.navbar .container { width: 1170px; }
	.container { width: 100%; }
	.body-content { padding: 0; margin: 0; }

	.mainWrapper { display: flex; flex-direction: column; position: relative; }
	.mainWrapper .mainHeader { display: flex; gap: 10px; align-items: center; position: sticky; top: 0; z-index: 100; background-color: #EEE; padding: 5px 10px; }
	.mainWrapper .mainHeader .mainTabButtons { display: flex; gap: 1px; }
	.mainWrapper .mainHeader .mainTabButtons button { border-radius: 0; border: 1px solid #AAA; padding: 5px; }
	.mainWrapper .mainHeader .mainTabButtons button:first-child { border-radius: 5px 0 0 5px; }
	.mainWrapper .mainHeader .mainTabButtons button:last-child { border-radius: 0 5px 5px 0; }
	.mainWrapper .mainHeader .mainSearchStatusBox { font-weight: bold; }
	.mainWrapper .mainHeader .exportBox { display: flex; gap: 10px; align-items: center; margin-left: auto; }
	.mainWrapper .mainHeader .exportBox .exportProgressBarBox { background-color: #555; padding: 1px; height: 26px; width: 200px; border-radius: 3px; }
	.mainWrapper .mainHeader .exportBox .exportProgressBarBox .exportProgressBar { background-color: #3A3; color: #FFF; padding: 2px; transition: width 0.2s; height: 100%; width: 0%; text-align: right; white-space: nowrap; }
	.mainWrapper .mainTabsBox {  }
	.mainWrapper .mainTabsBox .mainTab { display: flex; flex-direction: column; height: calc(100vh - 25px - 51px - 42px); /* 100vh - CUI banner - site header - main tab set header */ }
	.mainWrapper .mainTabsBox .mainTab:not(.selected) { display: none; }
	
	.mainSearchFiltersBox { padding: 0 20px; overflow-y: auto; }
	.mainSearchFiltersBox .filterGroup { padding: 20px 0; border-top: 1px solid #CCC; }
	.mainSearchFiltersBox .filterGroup:first-child { padding-top: 0; border-top: none; }
	.mainSearchFiltersBox .filterGroup .filterGroupHeader {  }
	.mainSearchFiltersBox .filterGroup .filterGroupContent { display: flex; gap: 20px; }
	.mainSearchFiltersBox .filterGroup .filterGroupContent .filterSet {  }
	.mainSearchFiltersBox .filterGroup .filterGroupContent .textFilterSet { flex: 0 0 300px; }
	.mainSearchFiltersBox .filterGroup .filterGroupContent .textFilterSet .filter {  }
	.mainSearchFiltersBox .filterGroup .filterGroupContent .filterLabel { font-weight: bold; }
	.mainSearchFiltersBox .filterGroup .filterGroupContent input[type='text'] { max-width: none; width: 100%; height: 30px; }
	.mainSearchFiltersBox .filterGroup .filterGroupContent label { display: flex; gap: 10px; align-items: baseline; font-weight: normal; width: 100%; padding: 0 5px; }
	.mainSearchFiltersBox .filterGroup .filterGroupContent label:is(:hover, :focus) { cursor: pointer; background-color: #EEE; }
	.mainSearchFiltersBox .filterGroup .filterGroupContent .textFilterSet .filter { margin-bottom: 10px; }
	.mainSearchFiltersBox .filterGroup .filterGroupContent .checkBoxListFilterSet { display: flex; gap: 10px; flex-wrap: wrap; width: 100%; }
	.mainSearchFiltersBox .filterGroup .filterGroupContent .checkBoxListFilterSet .filter { flex: 0 0 350px; }
	.mainSearchFiltersBox .filterGroup .filterGroupContent .checkBoxListFilterSet .filter .filterLabel { display: flex; gap: 10px; align-items: center; border-bottom: 1px solid #CCC; }
	.mainSearchFiltersBox .filterGroup .filterGroupContent .checkBoxListFilterSet .filter .filterLabel button { padding: 0 5px; margin-left: auto; font-weight: normal; }
	.mainSearchFiltersBox .filterGroup .filterGroupContent .textFilterSet .filter .filterContent { position: relative; }
	.mainSearchFiltersBox .filterGroup .filterGroupContent .textFilterSet .filter .filterContent .suggestionBox { position: absolute; top: 30px; margin-bottom: 20px; background-color: #FFF; max-height: 50vh; overflow-y: scroll; border: 1px solid #CCC; width: 100%; z-index: 10; }
	.mainSearchFiltersBox .filterGroup .filterGroupContent .textFilterSet .filter .filterContent .suggestionBox .suggestion { background-color: #FFF; border: none; padding: 5px; display: block; width: 100%; text-align: left; }
	.mainSearchFiltersBox .filterGroup .filterGroupContent .textFilterSet .filter .filterContent .suggestionBox .suggestion.cancel { background-color: #DDD; font-style: italic; }
	.mainSearchFiltersBox .filterGroup .filterGroupContent .textFilterSet .filter .filterContent .suggestionBox .suggestion:is(:hover, :focus) { background-color: #EEE; }
	.mainSearchFiltersBox .filterGroup .filterGroupContent .textFilterSet .filter .filterContent .selectedItemsBox { }
	.mainSearchFiltersBox .filterGroup .filterGroupContent .textFilterSet .filter .filterContent .selectedItemsBox .selectedItem { display: flex; align-items: baseline; gap: 10px; padding: 5px; }
	.mainSearchFiltersBox .filterGroup .filterGroupContent .textFilterSet .filter .filterContent .selectedItemsBox .selectedItem:not(:first-child) { border-top: 1px dashed #CCC; }
	.mainSearchFiltersBox .filterGroup .filterGroupContent .textFilterSet .filter .filterContent .selectedItemsBox .selectedItem button { margin-left: auto; }

	.rmtlBox { display: flex; flex-direction: column; height: 100%; }
	.rmtlBox .rmtlTableWrapper { flex: 1 1 auto; position: relative; overflow: scroll; }
	.rmtlBox .rmtlTableWrapper .rmtlTable { font-size: 12px; }
	.rmtlBox .rmtlTableWrapper .rmtlTable .rmtlTableHeader { position: sticky; top: 0; z-index: 10; }
	.rmtlBox .rmtlTableWrapper .rmtlTable .rmtlTableHeader th { padding: 5px 10px; min-width: 100px; border-right: 1px solid #CCC; }
	.rmtlBox .rmtlTableWrapper .rmtlTable .rmtlTableHeader th[data-part='PART I'] { background-color: #FC5; }
	.rmtlBox .rmtlTableWrapper .rmtlTable .rmtlTableHeader th[data-part='PART II'] { background-color: #FEA; }
	.rmtlBox .rmtlTableWrapper .rmtlTable .rmtlTableHeader th[data-part='PART III'] { background-color: #ACD; }
	.rmtlBox .rmtlTableWrapper .rmtlTable .rmtlTableBody {  }
	.rmtlBox .rmtlTableWrapper .rmtlTable .rmtlTableBody td { padding: 5px 10px; border: 1px solid #CCC; }
	.rmtlBox .rmtlFooter { height: 40px; background-color: #EEE; }
	.rmtlBox .rmtlFooter .rmtlPagingBox { display: flex; gap: 5px; justify-content: center; align-items: center; padding: 5px 10px; }

	.statisticsBox { padding: 0 20px; }
	.statisticsBox .statSection { margin-bottom: 50px; }
	.statisticsBox .statisticsTable { width: 100%; }
	.statisticsBox .statisticsTable :is([data-column='Source Type'], [data-column='Level Type'], [data-column='Pay Grade Type']) { text-align: left; width: 475px; }
	.statisticsBox .statisticsTable thead tr th { padding: 5px 10px; min-width: 50px; text-align: right; }
	.statisticsBox .statisticsTable tbody tr td { border-top: 1px solid #CCC; text-align: right; padding: 5px 10px; }
	.statisticsBox .statisticsTable tfoot tr th { border-top: 1px solid #CCC; text-align: right; padding: 5px 10px; }
	.statisticsBox .statisticsTable tbody tr td:first-child { text-align: left; }
	.statisticsBox .statisticsTable .statBarWrapper { background-color: #DDD; height: 18px; padding: 1px 2px; }
	.statisticsBox .statisticsTable .statBarWrapper .statBarAll { background-color: #D83; height: 100%; }
	.statisticsBox .statisticsTable .statBarWrapper .statBarAll .statBarCoverage { background-color: #0C3; height: 100%; }
</style>
<style type="text/css" class="rmtlStyleBox"></style>

<div class="mainWrapper">
	<div class="mainHeader">
		<div class="mainTabButtons"></div>
		<div class="mainSearchStatusBox"></div>
		<div class="mainSearchSpinner spinner"></div>
		<div class="mainSearchFilterEchoBox"></div>
		<div class="exportBox">
			<div class="exportProgressBarBox">
				<div class="exportProgressBar"></div>
			</div>
			<button data-action="ExportMainSearchResults">Export Results</button>
			<button data-action="CancelExportMainSearchResults">Cancel</button>
		</div>
	</div>
	<div class="mainTabsBox">
		<div class="mainTab" data-tab="Search and Filter">
			<div class="mainSearchFiltersBox">
				<div class="filterGroup part1Filters">
					<h4 class="filterGroupHeader">Part I Filters</h4>
					<div class="filterGroupContent">
						<div class="filterSet textFilterSet">
							<div class="filter" data-filter="> RatingId > Rating" data-filtertype="Suggestion" data-searchtype="Rating" data-label="Rating" data-hasdatahelper="< RatingId < RatingContext:NotNull" data-takesuggestions="100"></div>
							<div class="filter" data-filter="> BilletTitleId > Job" data-filtertype="Suggestion" data-searchtype="BilletTitle" data-label="Billet Title"></div>
							<div class="filter" data-filter="> WorkRoleId > WorkRole" data-filtertype="Suggestion" data-searchtype="WorkRole" data-label="Functional Area"></div>
							<div class="filter" data-filter="> RatingTaskId > RatingTask > ReferenceResourceId > ReferenceResource" data-filtertype="Suggestion" data-searchtype="ReferenceResource" data-label="Source"></div>
							<div class="filter" data-filter="> RatingTaskId > RatingTask.TextFields" data-filtertype="Text" data-label="Rating Task"></div>
						</div>
						<div class="filterSet checkBoxListFilterSet">
							<div class="filter" data-filter="> RatingTaskId > RatingTask > ReferenceResourceTypeId > Concept" data-filtertype="CheckBoxList" data-sourceuri="@Factories.ConceptSchemeManager.ConceptScheme_ReferenceResourceCategory"></div>
							<div class="filter" data-filter="> PayGradeTypeId > Concept" data-filtertype="CheckBoxList" data-sourceuri="@Factories.ConceptSchemeManager.ConceptScheme_PayGradeCategory"></div>
							<div class="filter" data-filter="> PayGradeLevelTypeId > Concept" data-filtertype="CheckBoxList" data-sourceuri="@Factories.ConceptSchemeManager.ConceptScheme_PayGradeLevelCategory"></div>
							<div class="filter" data-filter="> FormalTrainingGapId > Concept" data-filtertype="CheckBoxList" data-sourceuri="@Factories.ConceptSchemeManager.ConceptScheme_TrainingGapCategory"></div>
							<div class="filter" data-filter="> TaskApplicabilityId > Concept" data-filtertype="CheckBoxList" data-sourceuri="@Factories.ConceptSchemeManager.ConceptScheme_TaskApplicabilityCategory"></div>
						</div>
					</div>
				</div>
				<div class="filterGroup part2Filters">
					<h4 class="filterGroupHeader">Part II Filters</h4>
					<div class="filterGroupContent">
						<div class="filterSet textFilterSet">
							<div class="filter" data-filter="> CourseContextId > CourseContext > HasCourseId > Course" data-filtertype="Suggestion" data-searchtype="Course" data-label="Course"></div>
							<div class="filter" data-filter="> CourseContextId > CourseContext > HasTrainingTaskId > TrainingTask.TextFields" data-filtertype="Text" data-label="Training Task"></div>
							<div class="filter" data-filter="> CourseContextId > CourseContext > HasCourseId > Course > CurriculumControlAuthorityId > Organization" data-filtertype="Suggestion" data-searchtype="Organization" data-label="Curriculum Control Authority" data-hasdatahelper="< CurriculumControlAuthorityId < Course < HasCourseId < CourseContext < CourseContextId < RatingContext:NotNull"></div>
						</div>
						<div class="filterSet checkBoxListFilterSet">
							<div class="filter" data-filter="> CourseContextId > CourseContext > AssessmentMethodConceptId > Concept" data-filtertype="CheckBoxList" data-sourceuri="@Factories.ConceptSchemeManager.ConceptScheme_AssessmentMethodCategory"></div>
							<div class="filter" data-filter="> CourseContextId > CourseContext > HasCourseId > Course > CourseTypeConceptId > Concept" data-filtertype="CheckBoxList" data-sourceuri="@Factories.ConceptSchemeManager.ConceptScheme_CourseCategory"></div>
							<div class="filter" data-filter="> CourseContextId > CourseContext > HasCourseId > Course > LifeCycleControlDocumentTypeId > Concept" data-filtertype="CheckBoxList" data-sourceuri="@Factories.ConceptSchemeManager.ConceptScheme_LifeCycleControlDocumentCategory"></div>
						</div>
					</div>
				</div>
				<div class="filterGroup part3Filters">
					<h4 class="filterGroupHeader">Part III Filters</h4>
					<div class="filterGroupContent">
						<div class="filterSet textFilterSet">
							<div class="filter" data-filter="> ClusterAnalysisId > ClusterAnalysis > HasClusterAnalysisTitleId > ClusterAnalysisTitle" data-filtertype="Suggestion" data-searchtype="ClusterAnalysisTitle" data-label="Cluster Analysis Title"></div>
							<div class="filter" data-filter="> ClusterAnalysisId > ClusterAnalysis > CandidatePlatformConceptId > Concept" data-filtertype="SuggestionLocalConcept" data-sourceuri="@Factories.ConceptSchemeManager.ConceptScheme_CandidatePlatformTypeCategory"></div>
							<div class="filter" data-filter="> ClusterAnalysisId > ClusterAnalysis > CFMPlacementTypeId > Concept" data-filtertype="SuggestionLocalConcept" data-sourceuri="@Factories.ConceptSchemeManager.ConceptScheme_CFMPlacementCategory"></div>
							<div class="filter" data-filter="> ClusterAnalysisId > ClusterAnalysis.PriorityPlacement" data-filtertype="Text" data-label="Priority Placement"></div>
							<div class="filter" data-filter="> ClusterAnalysisId > ClusterAnalysis.EstimatedInstructionalTime" data-filtertype="Text" data-label="Estimated Instructional Time"></div>
							<div class="filter" data-filter="> ClusterAnalysisId > ClusterAnalysis.DevelopmentTime" data-filtertype="Text" data-label="Development Time"></div>
						</div>
						<div class="filterSet checkBoxListFilterSet">
							<div class="filter" data-filter="> ClusterAnalysisId > ClusterAnalysis > TrainingSolutionTypeId > Concept" data-filtertype="CheckBoxList" data-sourceuri="@Factories.ConceptSchemeManager.ConceptScheme_TrainingSolutionCategory"></div>
							<div class="filter" data-filter="> ClusterAnalysisId > ClusterAnalysis > RecommendedModalityTypeId > Concept" data-filtertype="CheckBoxList" data-sourceuri="@Factories.ConceptSchemeManager.ConceptScheme_RecommendedModalityCategory"></div>
							<div class="filter" data-filter="> ClusterAnalysisId > ClusterAnalysis > DevelopmentSpecificationTypeId > Concept" data-filtertype="CheckBoxList" data-sourceuri="@Factories.ConceptSchemeManager.ConceptScheme_DevelopmentSpecificationCategory"></div>
							<div class="filter" data-filter="> ClusterAnalysisId > ClusterAnalysis > DevelopmentRatioTypeId > Concept" data-filtertype="CheckBoxList" data-sourceuri="@Factories.ConceptSchemeManager.ConceptScheme_DevelopmentRatioCategory"></div>
							@*<div class="filter" data-filter="> ClusterAnalysisId > ClusterAnalysis > CandidatePlatformConceptId > Concept" data-filtertype="CheckBoxList" data-sourceuri="@Factories.ConceptSchemeManager.ConceptScheme_CandidatePlatformType"></div>
							<div class="filter" data-filter="> ClusterAnalysisId > ClusterAnalysis > CFMPlacementTypeId > Concept" data-filtertype="CheckBoxList" data-sourceuri="@Factories.ConceptSchemeManager.ConceptScheme_CFMPlacement"></div>*@
						</div>
					</div>
				</div>
				<div class="filterGroup metaFilters">
					<h4 class="filterGroupHeader">System Filters and Configuration</h4>
					<div class="filterGroupContent">
						<div class="filterSet textFilterSet">
							<div class="filter" data-filter="SortOrder" data-filtertype="SortOrder" data-label="Sort Order"></div>
							<div class="filter" data-filter="Notes" data-filtertype="Text" data-label="Notes"></div>
						</div>
						<div class="filterSet checkBoxListFilterSet">
							<div class="filter" data-filter="ShowHideColumns" data-filtertype="ShowHideColumns" data-label="Show/Hide Columns"></div>
							<div class="filter" data-filter="UtilityFilters" data-filtertype="CheckBoxListIndividualItems" data-sourceuri="UtilityFilters"></div>
						</div>
					</div>
				</div>
			</div>
		</div>
		<div class="mainTab" data-tab="RMTL Spreadsheet">
			<div class="rmtlBox">
				<div class="rmtlTableWrapper">
					<table class="rmtlTable">
						<thead class="rmtlTableHeader"></thead>
						<tbody class="rmtlTableBody"></tbody>
					</table>
				</div>
				<div class="rmtlFooter">
					<div class="rmtlPagingBox"></div>
				</div>
			</div>
		</div>
		<div class="mainTab" data-tab="Summary">
			<div class="statisticsBox">
				<div class="statSection">
					<h4>Task Summary Tables</h4>
					<p>The tables below are based on the total counts of Rating-level tasks in the system. <b>The total number of tasks shown below may differ from the total number of search results shown above.</b> This is because the search results are based on individual rows in RMTLs that reference tasks (more than one RMTL may reference the same task), whereas the tables below are based on the tasks themselves.</p>
				</div>
				<div class="statSection">
					<h4>Rating Tasks by Source Type for the Current Search Results</h4>
					<table class="statisticsTable ratingTasksBySourceTypeTable" data-typeheader="Source Type">
						<thead class="ratingTasksBySourceTypeTableHeader"></thead>
						<tbody class="ratingTasksBySourceTypeTableBody"></tbody>
						<tfoot class="ratingTasksBySourceTypeTableFooter"></tfoot>
					</table>
				</div>
				<div class="statSection">
					<h4>Rating Tasks by Pay Grade Level for the Current Search Results</h4>
					<table class="statisticsTable ratingTasksByPayGradeLevelTable" data-typeheader="Level Type">
						<thead class="ratingTasksByPayGradeLevelTableHeader"></thead>
						<tbody class="ratingTasksByPayGradeLevelTableBody"></tbody>
						<tfoot class="ratingTasksByPayGradeLevelTableFooter"></tfoot>
					</table>
				</div>
				<div class="statSection">
					<h4>Rating Tasks by Pay Grade for the Current Search Results</h4>
					<table class="statisticsTable ratingTasksByPayGradeTable" data-typeheader="Pay Grade Type">
						<thead class="ratingTasksByPayGradeTableHeader"></thead>
						<tbody class="ratingTasksByPayGradeTableBody"></tbody>
						<tfoot class="ratingTasksByPayGradeTableFooter"></tfoot>
					</table>
				</div>
			</div>
		</div>
	</div>
</div>

