<script type="text/javascript">
	//Namespace
	var AJAX = {
		RequestQueueMaxLength: 25,
		RequestQueue: [],
		Cache: []
	};

	//Do a generic POST Request
	AJAX.doPOSTRequest = function (url, body, onSuccess, onError) {
		AJAX.doFetch(url, onSuccess, onError, {
			method: "POST",
			headers: { "Accept": "application/json", "Content-Type": "application/json" },
			body: JSON.stringify(body || {})
		});
	}
	//

	//Do a generic GET Request
	AJAX.doGETRequest = function (url, onSuccess, onError) {
		AJAX.doFetch(url, onSuccess, onError);
	}
	//

	//Do a generic Fetch and process the results
	AJAX.doFetch = function (url, onSuccess, onError, options) {
		//Enable queueing requests so as not to overload the server
		var Request = {};
		Request.Status = "waiting";
		Request.URL = url;
		Request.run = function () {
			fetch(url, options)
				.then(response => {
					if (response.ok) {
						return response.text();
					}
					else {
						handleError(Request, onError, "Fetch Response Error", url, "Response Error Type 1. Error Code " + response.status + (response.statusText ? ": " + response.statusText : ""), response, onSuccess, null);
						processRequestQueue(Request);
					}
				}, responseError => {
					handleError(Request, onError, "Fetch Response Error", url, "Response Error Type 2. Error Code " + response.status + (response.statusText ? ": " + response.statusText : ""), responseError, onSuccess, null);
					processRequestQueue(Request);
				})
				.then(text => {
					try {
						onSuccess(JSON.parse(text));
						processRequestQueue(Request);
					}
					catch (e) {
						handleError(Request, onError, "JSON Parsing Error", url, "Error parsing JSON", value, onSuccess, e);
						processRequestQueue(Request);
					}
				}, textError => {
					handleError(Request, onError, "Fetch Parsing Error", url, "Error paring response text. Error Code " + response.status + (response.statusText ? ": " + response.statusText : ""), textError, onSuccess, null);
					processRequestQueue(Request);
				})
				.catch(networkError => {
					handleError(Request, onError, "Network Error", url, "Failed while calling resource: " + url, null, onSuccess, networkError);
					processRequestQueue(Request);
				});
		};
		AJAX.RequestQueue.push(Request);
		processRequestQueue();

		//Helper function
		function handleError(Request, onError, type, url, message, rawData, successFunction, jsError) {
			var error = { Request: Request, Type: type, URL: url, Message: message, RawData: rawData, SuccessFunction: successFunction, JSError: jsError };
			console.log("AJAX Error", error);
			onError?.(error);
			return error;
		}

		//Helper function
		function processRequestQueue(Request) {
			setTimeout(function () {
				if (Request) {
					AJAX.RequestQueue = AJAX.RequestQueue.filter(OtherRequest => OtherRequest != Request);
				}
				for (var i = 0; i < AJAX.RequestQueueMaxLength; i++) {
					if (AJAX.RequestQueue[i]?.Status == "waiting") {
						AJAX.RequestQueue[i].Status = "running";
						AJAX.RequestQueue[i].run();
					}
				}
			}, 0);
		}
	}
	//

	AJAX.cancelWaitingRequests = function () {
		AJAX.RequestQueue.filter(Request => Request.Status == "waiting").forEach(Request => {
			console.log("Cancelling Request", Request);
			AJAX.Cache = AJAX.Cache.filter(item => item.URL != Request.URL);
			AJAX.RequestQueue = AJAX.RequestQueue.filter(OtherRequest => OtherRequest != Request);
		});
	}
	//

	//Append the request (and handlers) for a resource to the cache. When the resource loads, run all of its handlers and then reset the handler lists. 
	AJAX.getResource = function (url, onSuccess, onError) {
		//Find the request if it already exists
		var Request = AJAX.Cache.find(item => item.URL == url);
		//If there's data for it already, run the success handler
		if (Request?.Data) {
			runHandler(Request.Data, onSuccess);
		}
		//If there's an error for it already, run the error handler
		else if (Request?.Error) {
			runHandler(Request.Error, onError);
		}
		//If there's a request, but no data and no error, then append the handlers (the request is still being retrieved)
		else if (Request) {
			Request.SuccessHandlers.push(onSuccess);
			Request.ErrorHandlers.push(onError);
		}
		//If there's no request at all, create/inject one and do the AJAX request. When the request finishes, run the handlers it has accumulated by that point, and clear them out.
		else {
			Request = AJAX.appendToCache(url);
			Request.SuccessHandlers.push(onSuccess);
			Request.ErrorHandlers.push(onError);
			AJAX.doGETRequest(url, response => {
				Request.Data = response.Data;
				processHandlers(Request, Request.Data, Request.SuccessHandlers);
			}, error => {
				Request.Error = error;
				processHandlers(Request, Request.Error, Request.ErrorHandlers);
			});
		}

		//Helper function to process handlers
		function processHandlers(Request, DataOrError, Handlers) {
			Handlers.forEach(handler => {
				handler?.(DataOrError);
			});
			Request.SuccessHandlers = [];
			Request.ErrorHandlers = [];
		}

		//Helper function to simulate the async nature of requests, so that they are consistently run asynchronously
		function runHandler(dataOrError, handler) {
			setTimeout(() => {
				handler?.(dataOrError);
			}, 0);
		}
	}
	//

	//Put a resource request into the cache, and add its data if the data is already loaded
	AJAX.appendToCache = function (url, data) {
		var Request = AJAX.Cache.find(item => item.URL == url);
		if (!Request) {
			Request = {
				URL: url,
				SuccessHandlers: [],
				ErrorHandlers: [],
				Data: data,
				Error: null
			};
			AJAX.Cache.push(Request);
		}

		return Request;
	}
	//
</script>
